<html>
  <head>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <style>
    html, body {
      width:  100%;
      height: 100%;
      margin: 0px;
      padding: 0px;
      overflow:auto;
      
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      
      font-family: verdana, meiryo, sans-serif, Arial Unicode MS, Cambria Math;
      
    }
  
    .molmil_UI_container {
    }
    
    .welcome {
      color: white;
      font-size: 5em;
      white-space: nowrap;
    }
    
  </style>
  
  <script>
    var molmil_settings = {src: "../../"}, RADIUS = 500;

    var canvas, cli;
    
    function panorama_mouseDown(event) {
      molmil.activeCanvas = this;
      molmil.Xcoord = event.clientX;
      molmil.Ycoord = event.clientY;
      molmil.mouseMoved = false;
    }
    
    function panorama_mouseUp(event) {
      molmil.activeCanvas = null;
    }
    
    var lon = 0, lat = 0;
    
    function panorama_mouseMove(event) {
      if (! molmil.activeCanvas) return;
      
      var clientX = event.clientX;
      var clientY = event.clientY;

      lon += ( molmil.Xcoord - event.clientX ) * 0.1;
      lat += ( event.clientY - molmil.Ycoord ) * 0.1;
      molmil.Xcoord = event.clientX;
      molmil.Ycoord = event.clientY;
      
      lat = Math.max( - 85, Math.min( 85, lat ) );
      var phi = glMatrix.toRadian( 90 - lat );
      var theta = glMatrix.toRadian( lon );
      
      
      
      var point = [RADIUS * Math.sin( phi ) * Math.cos( theta ), RADIUS * Math.cos( phi ), Math.sin( phi ) * Math.sin( theta )];
      
      console.log(point);

      var matrix = mat4.lookAt(mat4.create(), [0, 0, 0], point, [1, 0, 0]);
      mat4.getRotation(canvas.renderer.camera.QView, matrix);
      
      canvas.update = true;

      event.preventDefault();
    
    };
    
    
    function customPicker(x, y, event) {
      y = this.canvas.height-y;
      var gl = this.renderer.gl;
      if (! this.renderer.FBOs.pickingBuffer) {
        this.renderer.FBOs.pickingBuffer = new molmil.FBO(gl, this.renderer.width, this.renderer.height);
        this.renderer.FBOs.pickingBuffer.addTexture("colourBuffer", gl.RGBA, gl.RGBA);
        this.renderer.FBOs.pickingBuffer.setup();
      }
      else if (this.renderer.FBOs.pickingBuffer.width != this.renderer.width || this.renderer.FBOs.pickingBuffer.height != this.renderer.height) this.renderer.FBOs.pickingBuffer.resize(this.renderer.width, this.renderer.height);
  
      this.renderer.FBOs.pickingBuffer.bind();
      this.renderer.renderPicking();
      var data = new Uint8Array(4);
      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
      var u = (data[0]*255 + data[1])/65535;
      var v = (data[2]*255 + data[3])/65535;

      var texturePointer = canvas.WORLD.program.settings.texturePointer;
      var x = Math.round(u*texturePointer.image.width);
      var y = Math.round(v*texturePointer.image.height);

      var room = canvas.WORLD.rooms[texturePointer.id], d, u, v, theta, phi, x, y, z;
      for (d=0; d<room.doors.length; d++) {
         // doesn't work perfectly yet;
         // needs to be made compatible with periodicity...
         if (Math.pow(x-room.doors[d].x, 2)/Math.pow(room.doors[d].r1, 2) + Math.pow(y-room.doors[d].y, 2)/Math.pow(room.doors[d].r2, 2) <= 1) {
           // jump to the new room...
           canvas.WORLD.loadRoom(room.doors[d].to);
           break;
         }
      }

      this.renderer.FBOs.pickingBuffer.unbind();
      this.canvas.update = true;
    };
    
  
    function initViewer() {
      if (! window.molmil.configBox || ! molmil.configBox.initFinished) {return setTimeout(initViewer, 100);}
      
      molmil.configBox.camera_fovy = 75;
      molmil.configBox.glsl_shaders.push([window.location.href+"360sphere.glsl", "standard360sphere", ""]);
      molmil.configBox.glsl_shaders.push([window.location.href+"360sphere.glsl", "standard360sphere_picking", "#define PICKING_MODE 1\n"]);

      molmil.configBox.BGCOLOR = [0, 0, 0, 1];
      molmil.configBox.glAttribs = {preserveDrawingBuffer: true};
      
      //molmil.handle_molmilViewer_mouseDown = panorama_mouseDown;
      //molmil.handle_molmilViewer_mouseUp = panorama_mouseUp;
      //molmil.handle_molmilViewer_mouseMove = panorama_mouseMove;
      
      
      canvas = document.getElementById("molmilViewer");
      canvas.width = (window.innerWidth || document.documentElement.clientWidth);
      canvas.height = (window.innerHeight || document.documentElement.clientHeight);
      canvas = molmil.createViewer(canvas);
      
      window.onresize = function() {
        var dpr = devicePixelRatio || 1;
        canvas.style.width = (window.innerWidth || document.documentElement.clientWidth);
        canvas.style.height = (window.innerHeight || document.documentElement.clientHeight);
        if (molmil.configBox.stereoMode != 3) {
          canvas.width = (window.innerWidth || document.documentElement.clientWidth)*dpr;
          canvas.height = (window.innerHeight || document.documentElement.clientHeight)*dpr;
          canvas.renderer.resizeViewPort();
        }
        canvas.update = true;
      };
      
      molmil.autoSetup({enable: []});
      
      // change the mouse interface to be more panarama-friendly...
      
      canvas.renderer.camera.generateMatrix_ = canvas.renderer.camera.generateMatrix;
      canvas.renderer.camera.generateMatrix = function() {
        var matrix = this.generateMatrix_();
        //matrix[12] = 0;
        //matrix[13] = 0;
        //matrix[14] = 0;
        return matrix;
      };
      
      canvas.molmilViewer.selectObject = customPicker;
      
      loadWorld("ipr/world.json");
    }
    
    function loadWorld(url, data) {
      if (! data) {
        var request = new molmil_dep.CallRemote("GET"); request.ASYNC = true;
        request.OnDone = function() {loadWorld(url, this.request.responseText);};
        request.Send(url);
        return;
      }
      
      var world = JSON.parse(data); canvas.WORLD = world;
      var a = document.createElement("a"); a.href = url;
      world.baseURL = a.href.split("/").slice(0, -1).join("/").trim()+"/";
      world.catalogue = {};
      world.loadRoom = function(id) {
        if (id in this.catalogue) return this.setRoom(id);
        var image = new Image();
        image.onload = function() {
          var isPowerOf2 = function(value) {return (value & (value - 1)) == 0;};
          var gl = canvas.renderer.gl;
          var texture = gl.createTexture();
          texture.image = this;
          texture.id = id;
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this);
          if (isPowerOf2(this.width) && isPowerOf2(this.height)) gl.generateMipmap(gl.TEXTURE_2D);
          else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          }
          world.catalogue[id] = texture;
          world.setRoom(id);
        };
        if (! id in world.rooms) return console.log("Room", id, "not found...");
        this.catalogue[id] = false;
        image.src = this.baseURL+"textures/"+id.replace(/\./g, "/")+".jpg";
      };
      world.setRoom = function(id) {
        if (! this.catalogue[id]) return;
        if (! this.program) return createWorld(this.catalogue[id], this);
        this.program.settings.texturePointer = this.catalogue[id];
        this.updateLabels();
        canvas.update = true;
      }
      world.updateLabels = function() {
        while (canvas.molmilViewer.texturedBillBoards.length) { canvas.molmilViewer.texturedBillBoards.pop(); }
        
        var texturePointer = this.program.settings.texturePointer;
        var room = this.rooms[texturePointer.id], d, u, v, theta, phi, x, y, z;
        for (d=0; d<room.doors.length; d++) {
          u = room.doors[d].x/texturePointer.image.width;
          v = room.doors[d].y/texturePointer.image.height;
          
          theta = (-0.5+(1-u))*(2*Math.PI);
          phi = (0.5-v)*(Math.PI);
          
          x = Math.cos(phi) * Math.cos(theta) * 1;
          y = Math.sin(phi) * 1;
          z = Math.cos(phi) * Math.sin(theta) * 1;
          
          var xyz = [x,y,z];
          vec3.negate(xyz,xyz);
          vec3.scale(xyz, xyz, RADIUS);
          molmil.addLabel("X", {xyz: xyz, fontSize: RADIUS/5., alwaysFront: true, centerTexture: false, addBorder: true}, canvas.molmilViewer);

          //var objects = [{type: "sphere", coords: [xyz], rgba: [0, 255, 255, 255], radius: 100.0}];
          //molmil.geometry.generator(objects, canvas.molmilViewer, "Path", {solid: true, alphaMode: false});
        }
      };
      
      world.loadRoom(world["default-start"] || world.rooms[0].id);
    };
    
    function createWorld(texturePointer, world) {
      var programOptions = {solid: true, texturePointer: texturePointer, radius: RADIUS};
      var sphere = molmil.geometry.getSphere(1, 0);
      var vBuffer = Float32Array.from(sphere.normals);
      var iBuffer = Uint32Array.from(sphere.indices);
      
      var program = molmil.geometry.build_simple_render_program(vBuffer, iBuffer, canvas.renderer, programOptions);
      program.render = sphere360_renderer;
      program.renderPicking = sphere360_pickingRenderer;
      program.standard_shader = canvas.renderer.shaders.standard360sphere;
      program.pickingShader = canvas.renderer.shaders.standard360sphere_picking;
      program.standard_attributes = program.standard_shader.attributes;
      program.pickingAttributes = program.pickingShader.attributes;

      canvas.renderer.addProgram(program);
      
      world.program = program;
      world.updateLabels();

      canvas.renderer.initBuffers();
      canvas.update = true;
    }

    function sphere360_renderer(modelViewMatrix) {
      this.renderer.gl.useProgram(this.standard_shader.program);
      this.renderer.gl.uniformMatrix4fv(this.standard_shader.uniforms.modelViewMatrix, false, modelViewMatrix);
      this.renderer.gl.uniformMatrix4fv(this.standard_shader.uniforms.projectionMatrix, false, this.renderer.projectionMatrix);
      this.renderer.gl.uniform1f(this.standard_shader.uniforms.radius, this.settings.radius);

      this.renderer.gl.activeTexture(this.renderer.gl.TEXTURE0);
      this.renderer.gl.bindTexture(this.renderer.gl.TEXTURE_2D, this.settings.texturePointer);

      this.renderer.gl.bindBuffer(this.renderer.gl.ARRAY_BUFFER, this.vertexBuffer); 
      this.renderer.gl.bindBuffer(this.renderer.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    
      molmil.resetAttributes(this.renderer.gl);
      molmil.bindAttribute(this.renderer.gl, this.standard_attributes.in_Normal, 3, this.renderer.gl.FLOAT, false, 12, 0);
      molmil.clearAttributes(this.renderer.gl);
    

      if (this.angle) { // angle sucks, it only allows a maximum of 3M "vertices" to be drawn per call...
        var dv = 0, vtd;
        while ((vtd = Math.min(this.nElements-dv, 3000000)) > 0) {this.renderer.gl.drawElements(this.renderer.gl.TRIANGLES, vtd, this.renderer.gl.INDEXINT, dv*4); dv += vtd;}
      }
      else this.renderer.gl.drawElements(this.renderer.gl.TRIANGLES, this.nElements, this.renderer.gl.INDEXINT, 0);
    };

    function sphere360_pickingRenderer(modelViewMatrix) {
      this.renderer.gl.useProgram(this.pickingShader.program);
      this.renderer.gl.uniformMatrix4fv(this.pickingShader.uniforms.modelViewMatrix, false, modelViewMatrix);
      this.renderer.gl.uniformMatrix4fv(this.pickingShader.uniforms.projectionMatrix, false, this.renderer.projectionMatrix);
      this.renderer.gl.uniform1f(this.pickingShader.uniforms.radius, this.settings.radius);
      
      this.renderer.gl.bindBuffer(this.renderer.gl.ARRAY_BUFFER, this.vertexBuffer);
      this.renderer.gl.bindBuffer(this.renderer.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

      molmil.resetAttributes(this.renderer.gl);
      molmil.bindAttribute(this.renderer.gl, this.pickingAttributes.in_Normal, 3, this.renderer.gl.FLOAT, false, 12, 0);
      molmil.clearAttributes(this.renderer.gl);
      
      if (this.angle) { // angle sucks, it only allows a maximum of 3M "vertices" to be drawn per call...
        var dv = 0, vtd;
        while ((vtd = Math.min(this.nElements-dv, 3000000)) > 0) {this.renderer.gl.drawElements(this.renderer.gl.TRIANGLES, vtd, this.renderer.gl.INDEXINT, dv*4); dv += vtd;}
      }
      else this.renderer.gl.drawElements(this.renderer.gl.TRIANGLES, this.nElements, this.renderer.gl.INDEXINT, 0);
    };



  </script>
  
  </head>
  
  <body onload="initViewer();">
    <div class="molmil_popup_outer" style="z-index: 1; top: -.5em;">
      <div class = "molmil_popup_inner">

      </div>
    </div>
    <div class="molmil_UI_container">
      <canvas id="molmilViewer">
      </canvas>
    </div>
  </body>
  
  <script src="../../molmil.js"></script>
</html>